// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'network_exception.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$NetworkException {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NetworkExceptionCopyWith<$Res> {
  factory $NetworkExceptionCopyWith(
          NetworkException value, $Res Function(NetworkException) then) =
      _$NetworkExceptionCopyWithImpl<$Res, NetworkException>;
}

/// @nodoc
class _$NetworkExceptionCopyWithImpl<$Res, $Val extends NetworkException>
    implements $NetworkExceptionCopyWith<$Res> {
  _$NetworkExceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UnauthorizedExceptionImplCopyWith<$Res> {
  factory _$$UnauthorizedExceptionImplCopyWith(
          _$UnauthorizedExceptionImpl value,
          $Res Function(_$UnauthorizedExceptionImpl) then) =
      __$$UnauthorizedExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UnauthorizedExceptionImplCopyWithImpl<$Res>
    extends _$NetworkExceptionCopyWithImpl<$Res, _$UnauthorizedExceptionImpl>
    implements _$$UnauthorizedExceptionImplCopyWith<$Res> {
  __$$UnauthorizedExceptionImplCopyWithImpl(_$UnauthorizedExceptionImpl _value,
      $Res Function(_$UnauthorizedExceptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$UnauthorizedExceptionImpl extends _UnauthorizedException {
  const _$UnauthorizedExceptionImpl() : super._();

  @override
  String toString() {
    return 'NetworkException.unauthorizedException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnauthorizedExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) {
    return unauthorizedException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) {
    return unauthorizedException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) {
    if (unauthorizedException != null) {
      return unauthorizedException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) {
    return unauthorizedException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) {
    return unauthorizedException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) {
    if (unauthorizedException != null) {
      return unauthorizedException(this);
    }
    return orElse();
  }
}

abstract class _UnauthorizedException extends NetworkException {
  const factory _UnauthorizedException() = _$UnauthorizedExceptionImpl;
  const _UnauthorizedException._() : super._();
}

/// @nodoc
abstract class _$$OtherExceptionImplCopyWith<$Res> {
  factory _$$OtherExceptionImplCopyWith(_$OtherExceptionImpl value,
          $Res Function(_$OtherExceptionImpl) then) =
      __$$OtherExceptionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Type type});
}

/// @nodoc
class __$$OtherExceptionImplCopyWithImpl<$Res>
    extends _$NetworkExceptionCopyWithImpl<$Res, _$OtherExceptionImpl>
    implements _$$OtherExceptionImplCopyWith<$Res> {
  __$$OtherExceptionImplCopyWithImpl(
      _$OtherExceptionImpl _value, $Res Function(_$OtherExceptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$OtherExceptionImpl(
      null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Type,
    ));
  }
}

/// @nodoc

class _$OtherExceptionImpl extends _OtherException {
  const _$OtherExceptionImpl(this.type) : super._();

  @override
  final Type type;

  @override
  String toString() {
    return 'NetworkException.otherException(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OtherExceptionImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, type);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OtherExceptionImplCopyWith<_$OtherExceptionImpl> get copyWith =>
      __$$OtherExceptionImplCopyWithImpl<_$OtherExceptionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) {
    return otherException(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) {
    return otherException?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) {
    if (otherException != null) {
      return otherException(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) {
    return otherException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) {
    return otherException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) {
    if (otherException != null) {
      return otherException(this);
    }
    return orElse();
  }
}

abstract class _OtherException extends NetworkException {
  const factory _OtherException(final Type type) = _$OtherExceptionImpl;
  const _OtherException._() : super._();

  Type get type;

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OtherExceptionImplCopyWith<_$OtherExceptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormatExceptionImplCopyWith<$Res> {
  factory _$$FormatExceptionImplCopyWith(_$FormatExceptionImpl value,
          $Res Function(_$FormatExceptionImpl) then) =
      __$$FormatExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FormatExceptionImplCopyWithImpl<$Res>
    extends _$NetworkExceptionCopyWithImpl<$Res, _$FormatExceptionImpl>
    implements _$$FormatExceptionImplCopyWith<$Res> {
  __$$FormatExceptionImplCopyWithImpl(
      _$FormatExceptionImpl _value, $Res Function(_$FormatExceptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FormatExceptionImpl extends _FormatException {
  const _$FormatExceptionImpl() : super._();

  @override
  String toString() {
    return 'NetworkException.formatException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FormatExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) {
    return formatException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) {
    return formatException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) {
    if (formatException != null) {
      return formatException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) {
    return formatException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) {
    return formatException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) {
    if (formatException != null) {
      return formatException(this);
    }
    return orElse();
  }
}

abstract class _FormatException extends NetworkException {
  const factory _FormatException() = _$FormatExceptionImpl;
  const _FormatException._() : super._();
}

/// @nodoc
abstract class _$$ConnectionExceptionImplCopyWith<$Res> {
  factory _$$ConnectionExceptionImplCopyWith(_$ConnectionExceptionImpl value,
          $Res Function(_$ConnectionExceptionImpl) then) =
      __$$ConnectionExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConnectionExceptionImplCopyWithImpl<$Res>
    extends _$NetworkExceptionCopyWithImpl<$Res, _$ConnectionExceptionImpl>
    implements _$$ConnectionExceptionImplCopyWith<$Res> {
  __$$ConnectionExceptionImplCopyWithImpl(_$ConnectionExceptionImpl _value,
      $Res Function(_$ConnectionExceptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ConnectionExceptionImpl extends _ConnectionException {
  const _$ConnectionExceptionImpl() : super._();

  @override
  String toString() {
    return 'NetworkException.connectionException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) {
    return connectionException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) {
    return connectionException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) {
    if (connectionException != null) {
      return connectionException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) {
    return connectionException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) {
    return connectionException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) {
    if (connectionException != null) {
      return connectionException(this);
    }
    return orElse();
  }
}

abstract class _ConnectionException extends NetworkException {
  const factory _ConnectionException() = _$ConnectionExceptionImpl;
  const _ConnectionException._() : super._();
}

/// @nodoc
abstract class _$$MaintenanceExceptionImplCopyWith<$Res> {
  factory _$$MaintenanceExceptionImplCopyWith(_$MaintenanceExceptionImpl value,
          $Res Function(_$MaintenanceExceptionImpl) then) =
      __$$MaintenanceExceptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MaintenanceExceptionImplCopyWithImpl<$Res>
    extends _$NetworkExceptionCopyWithImpl<$Res, _$MaintenanceExceptionImpl>
    implements _$$MaintenanceExceptionImplCopyWith<$Res> {
  __$$MaintenanceExceptionImplCopyWithImpl(_$MaintenanceExceptionImpl _value,
      $Res Function(_$MaintenanceExceptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$MaintenanceExceptionImpl extends _MaintenanceException {
  const _$MaintenanceExceptionImpl() : super._();

  @override
  String toString() {
    return 'NetworkException.maintenanceException()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MaintenanceExceptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) {
    return maintenanceException();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) {
    return maintenanceException?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) {
    if (maintenanceException != null) {
      return maintenanceException();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) {
    return maintenanceException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) {
    return maintenanceException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) {
    if (maintenanceException != null) {
      return maintenanceException(this);
    }
    return orElse();
  }
}

abstract class _MaintenanceException extends NetworkException {
  const factory _MaintenanceException() = _$MaintenanceExceptionImpl;
  const _MaintenanceException._() : super._();
}

/// @nodoc
abstract class _$$ApiExceptionImplCopyWith<$Res> {
  factory _$$ApiExceptionImplCopyWith(
          _$ApiExceptionImpl value, $Res Function(_$ApiExceptionImpl) then) =
      __$$ApiExceptionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int? statusCode, String? message});
}

/// @nodoc
class __$$ApiExceptionImplCopyWithImpl<$Res>
    extends _$NetworkExceptionCopyWithImpl<$Res, _$ApiExceptionImpl>
    implements _$$ApiExceptionImplCopyWith<$Res> {
  __$$ApiExceptionImplCopyWithImpl(
      _$ApiExceptionImpl _value, $Res Function(_$ApiExceptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? statusCode = freezed,
    Object? message = freezed,
  }) {
    return _then(_$ApiExceptionImpl(
      statusCode: freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ApiExceptionImpl extends _ApiException {
  const _$ApiExceptionImpl({this.statusCode, this.message}) : super._();

  @override
  final int? statusCode;
  @override
  final String? message;

  @override
  String toString() {
    return 'NetworkException.apiException(statusCode: $statusCode, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ApiExceptionImpl &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, statusCode, message);

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ApiExceptionImplCopyWith<_$ApiExceptionImpl> get copyWith =>
      __$$ApiExceptionImplCopyWithImpl<_$ApiExceptionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unauthorizedException,
    required TResult Function(Type type) otherException,
    required TResult Function() formatException,
    required TResult Function() connectionException,
    required TResult Function() maintenanceException,
    required TResult Function(int? statusCode, String? message) apiException,
  }) {
    return apiException(statusCode, message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unauthorizedException,
    TResult? Function(Type type)? otherException,
    TResult? Function()? formatException,
    TResult? Function()? connectionException,
    TResult? Function()? maintenanceException,
    TResult? Function(int? statusCode, String? message)? apiException,
  }) {
    return apiException?.call(statusCode, message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unauthorizedException,
    TResult Function(Type type)? otherException,
    TResult Function()? formatException,
    TResult Function()? connectionException,
    TResult Function()? maintenanceException,
    TResult Function(int? statusCode, String? message)? apiException,
    required TResult orElse(),
  }) {
    if (apiException != null) {
      return apiException(statusCode, message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UnauthorizedException value)
        unauthorizedException,
    required TResult Function(_OtherException value) otherException,
    required TResult Function(_FormatException value) formatException,
    required TResult Function(_ConnectionException value) connectionException,
    required TResult Function(_MaintenanceException value) maintenanceException,
    required TResult Function(_ApiException value) apiException,
  }) {
    return apiException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UnauthorizedException value)? unauthorizedException,
    TResult? Function(_OtherException value)? otherException,
    TResult? Function(_FormatException value)? formatException,
    TResult? Function(_ConnectionException value)? connectionException,
    TResult? Function(_MaintenanceException value)? maintenanceException,
    TResult? Function(_ApiException value)? apiException,
  }) {
    return apiException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UnauthorizedException value)? unauthorizedException,
    TResult Function(_OtherException value)? otherException,
    TResult Function(_FormatException value)? formatException,
    TResult Function(_ConnectionException value)? connectionException,
    TResult Function(_MaintenanceException value)? maintenanceException,
    TResult Function(_ApiException value)? apiException,
    required TResult orElse(),
  }) {
    if (apiException != null) {
      return apiException(this);
    }
    return orElse();
  }
}

abstract class _ApiException extends NetworkException {
  const factory _ApiException({final int? statusCode, final String? message}) =
      _$ApiExceptionImpl;
  const _ApiException._() : super._();

  int? get statusCode;
  String? get message;

  /// Create a copy of NetworkException
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ApiExceptionImplCopyWith<_$ApiExceptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
